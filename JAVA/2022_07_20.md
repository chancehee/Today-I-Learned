2022_07_20  
* Eclipse sout + Ctrl + space = System.out.println(); 자동완성  

## 2차원 배열 순회/탐색  
* 특정 좌표로부터 주변을 탐색하는 경우, 배열의 범위를 벗어나지 않기 위한 코드 필요하다.
* 8방향 탐색
```java
class Test01 {
  // static 자원 = class 자원 = 클래스 내 어디에서든 접근 가능하다. (어디서든 접근이 가능하기 때문에 데이터 원본 변경 가능성 조심)
  static String[][] arr = {
    {"좌상", "상", "우상"},
    {"좌", "중간", "우" },
    {"좌하", "하", "우하"}
  }
  
  // non static 자원 = instance 자원 = class가 갖고있는 참조 자료형 = 메모리에 안올라가있다. = 클래스 객체 생성을 통해서 접근이 가능하다.
  String[][] arr2 = {
    {"좌상", "상", "우상"},
    {"좌", "중간", "우" },
    {"좌하", "하", "우하"}
  }
  
  public static void main(String[] args){
    // instance 자원 사용하기
    Test01 t = new Test01(); // 객체를 생성한다. = Heap영역에 메모리가 올라간다. 변수명은 Stack영역에 메모리가 올라간다.
    System.out.println(t.arr2[0][0]); // "좌상"
    
    // static 자원 사용하기
    System.out.println(arr[0][0]); // 객체 생성없이 사용이 가능하다. 'Test01.'이 생략된 형태이다. (같은 클래스 내에 존재하므로)
    
    // 8방향 탐색
    int[] dx = {-1, 1, 0, 0, -1, 1, -1, 1}; // 행 방향(위 아래)  (헷갈리지 않게 명확한 기준을 정하자)
    int[] dy = {0, 0, -1, 1, 1, -1, -1, 1}; // 열 방향(좌 우)
    
    int x = 0, y = 0; // 기준점
    for (int i = 0; i<dx.length; i++) {
       int nx = x + dx[i];
       int ny = y + dy[i];
      
       // 바운더리 검사
       if (0 <= nx && nx < arr.length && 0 <= ny && ny < arr[0].length) {
         System.out.println(arr[nx][ny]);
       }
    }
  }
}
```  

## sc.next()와 sc.nextLine()의 차이  
* sc.next(): 하나의 단어로 입력을 받는다. ex) "우리 나라 만세" -> "우리"
* sc.nextLine(): (한줄 단위) 엔터키를 입력하기 전까지의 문자열을 입력 받는다. ex) "우리 나라 만세" -> "우리 나라 만세"  

## enhanced for loop  
* 용도: 인덱스가 없는 자료구조를 보기 위해서 순회 용도로 제작 되었다. ex) Set 자료구조(인덱스가 없다.)  
```java
int[] arr = {1, 2, 3};
for (int a : arr) {
  System.out.printf("%d ", a); // 1 2 3 
}
```  

## Java Version 대변혁  
* 1.5 버전을 기준으로 많은 부분이 변해서, Java version 5라고 칭한다.
* 7.0 버전에서 람다기능 포함됨.
* 8.0 버전에서 함수기능 포함됨. (최소 8.0 이상의 버전을 사용해야 하는 이유)  

## 2차원 배열 지그재그로 순회하기  
* 왼쪽 -> 오른쪽, 오른쪽 -> 왼쪽, ...
```java
for (int i = 0; i<arr.length; i++) {
  for (int j = 0; j<arr[0].length; j++{
    System.out.printf("%d ", array[i][j + (m - 1 -2 * j) * (i % 2)]);  
  }
}
```  

## 2차원 배열 전치행렬 구하기  
```java
for (int i=0; i<N; i++){
  for (int j=0; j<N; j++){
    if (i < j) {
      int temp = arr[i][j];
      arr[i][j] = arr[j][i];
      arr[j][i] = temp;
    }
  }
}
```  

## 클래스와 객체  
* 클래스: 사물 개념을 기술하는 단위
* 객체(Object = instance): 프로그램에서 사용하기 위해 어떤 클래스 속성을 갖는 것을 하나 만든 것. (객체 생성시: 하드디스크 -> 메모리)  

## Javadoc 생성하기  
* 만든 프로그램이 어떻게 구성되어 있고, 어떻게 사용할지 설명해주는 설명서 문서이다.
* 순서1) /** + enter 를 통해서 명세를 적는다. 순서2) cmd에 Javadoc *.java -encoding utf-8 입력 -> 생성됨

## Primitve 변수와 Reference 변수의 메모리 할당  
* Primitive: 4byte
* Reference: 8byte  

## this 키워드  
* static 영역에서는 this 키워드 사용 불가.
* Heap 영역에서만 사용 가능하다. 
* this 키워드는 객체에 대한 참조 키워드이다.  

## 객체 생성 시 내부적인 메모리 로직  
* String msg; -> 로직1). 패지키안에서 클래스를 찾는다. 로직2). JRE 라이브러리에서 찾는다. rt.jar -> java.lang -> String.class 발견
* Apple a = null; -> 데이터 타입이 Apple 타입이다. Apple.class가 존재해야지 에러가 발생하지 않는다. 또한 null인 경우에는 '.'참조 연산자 사용 불가능
* Apple[] a = new Apple[10]; -> Apple타입으로 10개의 변수를 할당하는 1차원 배열 (4byte * 10 = 40byte 할당)
* Banana b = new Banana(); -> '()' 얘는 함수 모양이다. = 객체를 생성한다고 말한다. (객체 생성시 불려지는 생성자 함수이다.) = (기본 생성자)
* 사용자 정의 생성자를 조작하면 기본 생성자는 사라진다. 따라서 2개의 생성자를 정의해줘야 한다.
* 생성자 용도: 일반적으로 초기화 작업을 구현 해준다. (this 키워드를 통해 로컬 변수인지 맴버 변수인지 구분한다.)
* 클래스는 생성시 컴파일러가 bin 폴더에 생성한다.

## String.format  
* String data = String.format("format", args); // 내가 지정한 형식으로 문자열을 만들어 주는 메소드이다.  

## 오버로딩 VS 오버라이딩  
1. 오버로딩
  * 정의: 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메소드를 정의할 수 있다.
  * 조건: 메소드의 이름이 같고, 매개변수의 개수나 타입이 달라야 한다. 주의할 점은 **'리턴 값'** 만 다른 것은 오버로딩을 할 수 없다.
  * 사용이유: 같은 기능을 하는 메소드를 하나의 이름으로 사용할 수 있다. 메소드의 이름을 절약할 수 있다.
  * 적용 범위: 같은 클래스 내에서 적용된다.
2. 오버라이딩
  * 정의: 부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의하는 것.
  * 조건: 자식 클래스에서는 오버라이딩하고자 하는 메소드의 이름, 매개변수, 리턴 값이 모두 같아야 한다.
  * 적용 범위: 상속관계에서 적용된다.






